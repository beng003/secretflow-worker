# Ray架构澄清说明

## 📋 重要发现

通过研究SecretFlow v1.12.0b0官方源码和文档，我们发现了关于Ray集群部署的重要架构理解：

### ❌ 之前的误解

我们最初认为需要配置Ray worker节点连接到Ray头节点：
- 节点1：Ray头节点
- 节点2：Ray worker节点（连接到节点1）

### ✅ 正确的架构

**每个SecretFlow节点都启动自己独立的Ray集群（头节点模式）**，节点间通过SecretFlow的`cluster_config`进行通信，而不是通过Ray的worker节点。

---

## 🔍 官方架构分析

### SecretFlow的Ray使用方式

根据官方代码分析（`secretflow_fl/distributed/op_strategy.py`）：

```python
# SecretFlow内部使用ray.init()连接到Ray集群
ray.init(
    address,  # 连接到本地或远程Ray集群
    num_cpus=num_cpus,
    num_gpus=num_gpus,
    log_to_driver=log_to_driver,
    **kwargs,
)
```

### 生产模式部署流程

1. **每个机构独立部署Ray集群**：
   ```bash
   # 每个节点都运行
   ray start --head
   # 或使用Python API
   ray.init(address=None)  # 启动新的独立集群
   ```

2. **SecretFlow通过cluster_config通信**：
   ```python
   cluster_config = {
       'parties': {
           'alice': {
               'address': '192.168.1.10:19000',
               'listen_addr': '0.0.0.0:19000'
           },
           'bob': {
               'address': '192.168.1.11:19000',
               'listen_addr': '0.0.0.0:19000'
           },
       },
       'self_party': 'alice'
   }
   sf.init(address='本地Ray地址', cluster_config=cluster_config)
   ```

---

## 🏗️ 架构对比

### 单节点部署

**之前的理解**：
```
节点1: Ray头节点 + Worker连接自己
```

**正确的架构**：
```
节点1: 独立Ray集群 + Celery Worker
       └─> 任务执行时通过sf.init()连接本地Ray
```

### 多节点部署

**之前的理解**：
```
节点1: Ray头节点
节点2: Ray worker节点 ──连接──> 节点1的Ray头节点
```

**正确的架构**：
```
节点1: 独立Ray集群 + Celery Worker
       └─> sf.init(cluster_config)
                ↓
         SecretFlow通信层
                ↑
节点2: 独立Ray集群 + Celery Worker
       └─> sf.init(cluster_config)
```

---

## 🔧 实施的简化

### 移除的配置项

1. **RAY_NODE_TYPE**：不再需要区分head/worker
2. **RAY_HEAD_ADDRESS**：每个节点都是独立集群，不需要连接地址

### 简化后的配置

```bash
# 所有节点使用相同的Ray配置
NODE_ID=node1
NODE_IP=192.168.1.10
RAY_PORT=61379  # 参考值，实际端口自动选择
RAY_NUM_CPUS=0
RAY_OBJECT_STORE_MEMORY=2000000000
```

### 简化后的启动脚本

```bash
# entrypoint.sh
# 使用ray start命令启动独立的Ray集群
ray start --head \
    --node-ip-address="${NODE_IP}" \
    --port="${RAY_PORT:-61379}" \
    --num-cpus="${RAY_NUM_CPUS:-0}" \
    --object-store-memory="${RAY_OBJECT_STORE_MEMORY:-2000000000}" \
    --include-dashboard=False \
    --disable-usage-stats
```

**注意**：虽然`ray status`命令在Python 3.10下可能有兼容性问题，但`ray start`命令可以正常工作。我们忽略健康检查中的`ray status`问题，改用进程检查。

---

## 💡 关键理解

### Ray的作用

Ray在SecretFlow中的作用是：
- 提供**本地**分布式计算能力
- 管理**单个节点**内的资源和任务调度
- **不负责**跨节点通信

### SecretFlow的作用

SecretFlow负责：
- 跨节点的安全多方计算协议
- 通过`cluster_config`管理节点间通信
- 使用各节点的本地Ray集群执行计算任务

### 通信层次

```
应用层: Celery任务分发
         ↓
SecretFlow层: 多方计算协议 (cluster_config)
         ↓
Ray层: 本地分布式计算 (每个节点独立)
```

---

## 📝 配置变更总结

### 移除的环境变量

- `RAY_NODE_TYPE` - 不再需要
- `RAY_HEAD_ADDRESS` - 不再需要

### 保留的环境变量

- `NODE_ID` - 节点标识
- `NODE_IP` - 节点IP（用于SecretFlow通信）
- `RAY_PORT` - Ray端口参考值
- `RAY_NUM_CPUS` - CPU配置
- `RAY_OBJECT_STORE_MEMORY` - 内存配置

### 简化的脚本

- `init_ray_cluster.py` - 统一的Ray集群启动脚本
- `entrypoint.sh` - 移除节点类型判断

---

## ✅ 优势

1. **配置更简单**：所有节点使用相同配置
2. **架构更清晰**：每个节点独立，职责明确
3. **符合官方设计**：与SecretFlow官方架构一致
4. **易于扩展**：添加新节点只需复制配置

---

## 🎯 部署指导

### 单节点部署

```bash
# 1. 配置环境变量
NODE_ID=node1
NODE_IP=***.***.***.***

# 2. 启动容器（自动启动独立Ray集群）
docker compose up -d

# 3. 任务代码中连接本地Ray
sf.init(address='auto')  # 自动连接本地Ray
```

### 多节点部署

```bash
# 节点1
NODE_ID=alice
NODE_IP=192.168.1.10

# 节点2
NODE_ID=bob
NODE_IP=192.168.1.11

# 任务代码中配置多方通信
cluster_config = {
    'parties': {
        'alice': {'address': '192.168.1.10:19000', ...},
        'bob': {'address': '192.168.1.11:19000', ...},
    },
    'self_party': 'alice'  # 当前节点
}
sf.init(address='auto', cluster_config=cluster_config)
```

---

**文档版本**：v3.0  
**更新时间**：2026年1月6日  
**重要性**：⭐⭐⭐⭐⭐（架构核心理解）
